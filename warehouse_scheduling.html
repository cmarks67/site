<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Warehouse Scheduling – Plan vs Actual</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      /* Brand-level colours – align these to your main site */
      --brand-primary: #1b6ac9;   /* primary accent */
      --brand-primary-soft: #e3efff;
      --brand-dark: #0b1b3a;
      --brand-border: #d0d4dc;
      --brand-bg: #f5f7fb;

      /* UI tokens derived from brand */
      --bg: var(--brand-bg);
      --card-bg: #ffffff;
      --border: var(--brand-border);
      --accent: var(--brand-primary);
      --accent-soft: var(--brand-primary-soft);
      --text-main: #1f2933;
      --text-muted: #6b7280;
      --danger: #c0392b;
      --success: #1e8449;
      --neutral: #7f8c8d;
      --radius-lg: 12px;
      --shadow-soft: 0 6px 18px rgba(15, 23, 42, 0.08);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    .page {
      max-width: 1200px;
      margin: 24px auto 40px;
      padding: 0 16px;
    }

    /* Sticky wrapper for header + KPIs */
    .sticky-header {
      position: sticky;
      top: 0;
      z-index: 40;
      background: linear-gradient(to bottom, #f9fafb, var(--bg));
      padding-bottom: 8px;
    }

    .top-bar {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 12px;
      padding: 10px 12px;
      border-radius: var(--radius-lg);
      background: #ffffff;
      box-shadow: var(--shadow-soft);
      border: 1px solid #e2e8f0;
    }

    .brand-wrap {
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 0;
    }

    .logo-wrap {
      width: 40px;
      height: 40px;
      border-radius: 12px;
      background: var(--accent-soft);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .logo-img {
      max-width: 32px;
      max-height: 32px;
      display: block;
    }

    .title-wrap {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .top-bar h1 {
      margin: 0;
      font-size: 1.3rem;
      color: var(--brand-dark);
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .top-bar .subtitle {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: flex-end;
    }

    label {
      font-size: 0.8rem;
      color: var(--text-muted);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    input[type="date"],
    select,
    input[type="number"],
    input[type="text"] {
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      font-size: 0.85rem;
      min-width: 80px;
      background: #f9fafb;
    }

    input[type="number"] { text-align: right; }
    input[type="file"]   { font-size: 0.8rem; }

    /* Generic buttons */
    .btn {
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.8rem;
      cursor: pointer;
      border: 1px solid var(--border);
      background: #f1f5f9;
      transition: background 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
    }
    .btn:hover {
      background: #e2e8f0;
      box-shadow: 0 1px 4px rgba(15, 23, 42, 0.12);
    }

    .btn-primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #ffffff;
    }
    .btn-primary:hover {
      background: #1555a0;
      border-color: #1555a0;
    }

    .btn-ghost {
      background: #ffffff;
      border-color: #d1d5db;
      color: var(--text-main);
    }
    .btn-ghost:hover {
      background: #f3f4f6;
    }

    /* Back button */
    .back-button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      border: 1px solid #d1d5db;
      background: #ffffff;
      color: var(--text-main);
      cursor: pointer;
      white-space: nowrap;
    }
    .back-button span {
      font-size: 0.9rem;
    }
    .back-button:hover {
      background: #f3f4f6;
      border-color: #cbd5f5;
    }

    .kpi-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 10px;
      margin-bottom: 8px;
    }

    .kpi-card {
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      padding: 10px 12px;
      box-shadow: var(--shadow-soft);
      border: 1px solid #e2e8f0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    }

    .kpi-card h2 {
      margin: 0 0 4px;
      font-size: 0.9rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    .kpi-card p {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-main);
    }

    .kpi-card small {
      margin-top: 4px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .kpi-card.ok {
      border-left: 4px solid var(--success);
      background: #e6f4ea;
    }
    .kpi-card.ok h2,
    .kpi-card.ok p {
      color: #145a32;
    }

    .kpi-card.warning {
      border-left: 4px solid var(--danger);
      background: #fdecea;
    }
    .kpi-card.warning h2,
    .kpi-card.warning p {
      color: #922b21;
    }

    .kpi-card input.indirect-limit-input {
      width: 60px;
      padding: 2px 4px;
      font-size: 0.75rem;
      text-align: right;
      margin-left: 4px;
      margin-right: 2px;
    }

    @keyframes flash-red {
      from { box-shadow: 0 0 0 rgba(192,57,43,0.2); }
      to   { box-shadow: 0 0 18px rgba(192,57,43,0.8); }
    }

    .indirect-alert {
      animation: flash-red 0.9s ease-in-out infinite alternate;
    }

    .panel {
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      padding: 14px 16px;
      margin-bottom: 16px;
      box-shadow: var(--shadow-soft);
      border: 1px solid #e2e8f0;
    }

    .panel-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 10px;
    }

    .panel h2 {
      margin: 0;
      font-size: 1rem;
      color: var(--brand-dark);
    }

    .panel-header small {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
    }

    thead { background: #f8fafc; }

    th, td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: left;
    }

    th {
      font-weight: 600;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    td.numeric {
      text-align: right;
      white-space: nowrap;
    }

    td input[type="number"] { width: 100%; }

    .variance { font-weight: 600; }
    .variance.pos     { color: var(--success); }
    .variance.neg     { color: var(--danger); }
    .variance.neutral { color: var(--neutral); }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: var(--accent-soft);
      color: var(--accent);
    }

    .footer-note {
      margin-top: 8px;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-align: right;
    }

    .inline-controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      font-size: 0.8rem;
      margin-bottom: 8px;
    }

    .inline-controls button {
      /* use generic button styling */
      font-size: 0.78rem;
    }

    .message {
      margin-top: 6px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .message.error   { color: var(--danger); }
    .message.success { color: var(--success); }

    .read-only-note {
      margin-top: 4px;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-align: left;
    }

    .sidebar-toggle {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--accent-soft);
      font-size: 0.8rem;
      cursor: pointer;
      margin-left: 4px;
      color: var(--accent);
    }

    .sidebar-toggle:hover {
      background: #cbdfff;
    }

    .sidebar {
      position: fixed;
      top: 0;
      right: -520px;
      width: 520px;
      height: 100%;
      background: #ffffff;
      box-shadow: -4px 0 12px rgba(15, 23, 42, 0.25);
      padding: 16px 16px 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: right 0.25s ease-in-out;
      z-index: 1000;
      overflow-y: auto;
    }

    @media (max-width: 640px) {
      .sidebar {
        width: 100%;
        right: -100%;
      }

      .top-bar {
        align-items: flex-start;
      }

      .controls {
        justify-content: flex-start;
      }
    }

    .sidebar.open { right: 0; }

    .sidebar-header {
      position: sticky;
      top: 0;
      background: #ffffff;
      padding-bottom: 8px;
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #e5e7eb;
      z-index: 1;
    }

    .sidebar-header h2 {
      font-size: 1rem;
      margin: 0;
    }

    .sidebar-close {
      border: none;
      background: transparent;
      font-size: 1.1rem;
      cursor: pointer;
    }

    .sidebar-section-title {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-muted);
      margin-top: 8px;
      margin-bottom: 4px;
    }

    .sidebar small {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .sidebar-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
      margin-bottom: 4px;
    }

    .sidebar-table th,
    .sidebar-table td {
      border: 1px solid #e5e7eb;
      padding: 4px 6px;
    }

    .sidebar-table th {
      background: #f9fafb;
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: var(--text-muted);
    }

    .sidebar-table input[type="text"],
    .sidebar-table input[type="number"],
    .sidebar-table select {
      width: 100%;
      font-size: 0.78rem;
      padding: 3px 4px;
    }

    .sidebar-button-row {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 4px;
    }

    .sidebar-button-row button {
      padding: 5px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #f1f5f9;
      font-size: 0.78rem;
      cursor: pointer;
    }

    .sidebar-button-row button:hover {
      background: #e2e8f0;
    }

    .btn-icon {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 0.9rem;
      line-height: 1;
      padding: 0 4px;
      color: #9ca3af;
    }

    .btn-icon:hover { color: #ef4444; }

    .sidebar-pill {
      font-weight: 600;
      color: var(--text-main);
    }

    /* Row-level red/green highlighting for tables */
    .table-row-warning td {
      background: #fdecea !important;
    }

    .table-row-ok td {
      background: #e6f4ea !important;
    }
  </style>
</head>
<body>
<div class="page">

<!-- Sticky header: branding + controls + KPI summary -->
<div class="sticky-header">
  <header class="top-bar">

    <div class="brand-wrap" style="display:flex; flex-direction:column; gap:2px;">

      <!-- Text logo -->
      <div class="logo-wrap" style="background: transparent; box-shadow: none; padding: 0;">
        <div style="margin:0; font-size:1.1rem; font-weight:600;">
          Warehouse <span style="color:#e63946;">Intelligence</span>
        </div>
      </div>

      <!-- Page title + subtitle -->
      <div class="title-wrap" style="margin-top:-4px;">
        <h1 style="margin:0; font-size:1.25rem;">Warehouse Scheduling – Plan vs Actual</h1>
        <div class="subtitle" style="font-size:0.85rem; margin-top:2px;">
          Multi-day · Multi-shift · Configurable tasks &amp; MHE · HTML/JS prototype
        </div>
      </div>

    </div>

    <div class="controls">
      <!-- Back to dashboard button -->
      <button type="button"
              class="back-button"
              onclick="window.location.href='dashboard.html';">
        <span>←</span>
        <span>Back to dashboard</span>
      </button>

      <label>
        Date
        <input type="date" id="shift-date">
      </label>
      <label>
        Shift
        <select id="shift-name">
          <option value="AM">AM</option>
          <option value="PM">PM</option>
          <option value="Nights">Nights</option>
        </select>
      </label>
      <label>
        View
        <select id="view-mode">
          <option value="Shift">Shift</option>
          <option value="Day">Day (all shifts)</option>
          <option value="Week">Week (all days)</option>
        </select>
      </label>

      <button type="button" id="btn-toggle-sidebar" class="sidebar-toggle">
        Task &amp; MHE setup
      </button>
    </div>

  </header>
</div>



    <!-- KPI layout -->
    <section class="kpi-row">
      <div class="kpi-card" id="kpi-direct-card">
        <h2>Direct hours</h2>
        <p>
          Plan: <span id="kpi-direct-plan">0.00</span>h<br>
          Actual: <span id="kpi-direct-actual">0.00</span>h
        </p>
        <small>Productive task time – plan vs actual.</small>
      </div>
      <div class="kpi-card" id="kpi-indirect-card">
        <h2>Indirect hours</h2>
        <p>
          Plan: <span id="kpi-indirect-plan">0.00</span>h<br>
          Actual: <span id="kpi-indirect-actual">0.00</span>h
        </p>
        <small>
          Indirect: <span id="kpi-indirect-pct">0.0</span>% of plan – Limit
          <input type="number" id="indirect-limit"
                 class="indirect-limit-input"
                 min="0" max="100" step="0.5" value="5">%
        </small>
      </div>
      <div class="kpi-card" id="kpi-labour-card">
        <h2>Labour cost</h2>
        <p>
          £<span id="kpi-cost-plan">0.00</span> /
          £<span id="kpi-cost-actual">0.00</span>
        </p>
        <small id="kpi-cost-note">
          From MHE hourly rates × planned / actual hours.
        </small>
      </div>
      <div class="kpi-card" id="kpi-total-card">
        <h2>Total hours – plan / expected / actual</h2>
        <p>
          Plan: <span id="kpi-total-plan">0.00</span>h<br>
          Expected (capacity): <span id="kpi-total-available">0.00</span>h<br>
          Actual: <span id="kpi-total-actual">0.00</span>h
        </p>
        <small>
          Variance (expected − plan): <span id="kpi-total-variance">0.00</span>h
        </small>
      </div>
    </section>
  </div>

  <!-- Upload / export section -->
  <section class="panel">
    <div class="panel-header">
      <h2>Upload &amp; export – Plan &amp; Actual</h2>
      <small>
        Preferred CSV columns: Date, Shift, Task, PlanVolume, ActualVolume.
        Older format (Task, PlanVolume, ActualVolume) also accepted for the current day/shift.
      </small>
    </div>
    <div class="inline-controls">
      <label>
        Import CSV
        <input type="file" id="csv-upload" accept=".csv,text/csv">
      </label>
      <button type="button" id="btn-download-template" class="btn btn-ghost">
        Download CSV template (current day/shift)
      </button>
      <button type="button" id="btn-download-full-data" class="btn btn-ghost">
        Download full dataset CSV
      </button>
      <button type="button" id="btn-clear-volumes" class="btn btn-ghost">
        Clear all volumes (all days/shifts)
      </button>
    </div>
    <div id="upload-message" class="message"></div>
    <div class="footer-note">
      Task names must match the “Task” column below (case-insensitive). Date/Shift columns route rows to the correct context.
    </div>
  </section>

  <!-- Summary by MHE -->
  <section class="panel">
    <div class="panel-header">
      <h2>Summary by MHE</h2>
      <small id="summary-caption">For the selected date and shift.</small>
    </div>
    <table id="summary-by-mhe">
      <thead>
      <tr>
        <th>MHE Type</th>
        <th>£/hr</th>
        <th>Planned hours required</th>
        <th>Planned labour cost</th>
        <th>Hours available (input)</th>
        <th>Plan variance</th>
        <th>Actual hours used</th>
        <th>Actual labour cost</th>
        <th>Actual variance</th>
      </tr>
      </thead>
      <tbody>
      <!-- rows built dynamically from MHE types -->
      </tbody>
    </table>
    <div class="footer-note">
      In Shift view, these hours are editable per day/shift. In Day/Week view they are aggregated and read-only.
    </div>
  </section>

  <!-- Task table: plan vs actual -->
  <section class="panel" id="tasks-panel">
    <div class="panel-header">
      <h2>Task details – Plan vs Actual</h2>
      <small id="tasks-caption">For the selected date and shift.</small>
    </div>
    <table id="tasks-table">
      <thead>
      <tr>
        <th>Task</th>
        <th>Area / Zone</th>
        <th>MHE type</th>
        <th>Unit</th>
        <th>Minutes per unit</th>
        <th>Plan volume</th>
        <th>Plan hours</th>
        <th>Actual volume</th>
        <th>Actual hours</th>
        <th>Productivity (units/hr)</th>
      </tr>
      </thead>
      <tbody>
      <!-- JS injects rows -->
      </tbody>
    </table>
    <div class="read-only-note" id="tasks-readonly-note" style="display:none;">
      Day/Week view shows aggregated volumes across shifts/days. Switch back to Shift view to edit volumes.
    </div>
    <div class="footer-note">
      Volumes are in the configured unit per task (Pallets or Units). Productivity is calculated per that unit.
    </div>
  </section>

  <!-- Range summary by day -->
  <section class="panel">
    <div class="panel-header">
      <h2>Range summary – by day</h2>
      <small>Aggregated daily totals (all shifts) between the selected dates.</small>
    </div>
    <div class="inline-controls">
      <label>
        From
        <input type="date" id="range-from">
      </label>
      <label>
        To
        <input type="date" id="range-to">
      </label>
      <button type="button" id="btn-refresh-range" class="btn btn-ghost">
        Refresh range summary
      </button>
      <button type="button" id="btn-download-range-csv" class="btn btn-ghost">
        Download range summary CSV
      </button>
      <button type="button" id="btn-print-range" class="btn btn-primary">
        Print / PDF
      </button>
    </div>
    <table id="range-summary-table">
      <thead>
      <tr>
        <th>Date</th>
        <th>Planned hours</th>
        <th>Hours available</th>
        <th>Actual hours</th>
        <th>Plan variance</th>
        <th>Actual variance</th>
      </tr>
      </thead>
      <tbody>
      <!-- JS will inject rows -->
      </tbody>
    </table>
    <div class="footer-note">
      Use your browser's print dialog and choose “Save as PDF” to archive or share this summary.
    </div>
  </section>
</div>

<!-- Slide-out sidebar for Task & MHE configuration -->
<div id="config-sidebar" class="sidebar">
  <div class="sidebar-header">
    <h2>Task &amp; MHE setup</h2>
    <button type="button" id="sidebar-close" class="sidebar-close" title="Close">&times;</button>
  </div>

  <!-- MHE assets grid -->
  <div>
    <div class="sidebar-section-title">MHE assets</div>
    <small>
      Maintain a simple register of MHE pieces. The <strong>Type</strong> text is reused in the task dropdowns, MHE summary and cost.
    </small>
    <div style="margin:4px 0 4px; font-size:0.8rem;">
      Total MHE: <span id="mhe-total-count" class="sidebar-pill">0</span>
    </div>
    <table id="mhe-config-table" class="sidebar-table">
      <thead>
      <tr>
        <th>Label</th>
        <th>Type</th>
        <th>Count</th>
        <th>£/hr</th>
        <th></th>
      </tr>
      </thead>
      <tbody>
      <!-- JS injects rows -->
      </tbody>
    </table>
    <div class="sidebar-button-row">
      <button type="button" id="btn-add-mhe-row">Add MHE</button>
    </div>
  </div>

  <!-- Task config grid -->
  <div>
    <div class="sidebar-section-title">Tasks &amp; productivity</div>
    <small>
      Each row defines a task: area, direct/indirect category, linked MHE type, unit and minutes per unit.
    </small>
    <table id="task-config-table" class="sidebar-table">
      <thead>
      <tr>
        <th>Task</th>
        <th>Area</th>
        <th>Category</th>
        <th>MHE</th>
        <th>Unit</th>
        <th>Min / unit</th>
        <th></th>
      </tr>
      </thead>
      <tbody>
      <!-- JS injects rows -->
      </tbody>
    </table>
    <div class="sidebar-button-row">
      <button type="button" id="btn-add-task-row">Add task</button>
    </div>
    <small>
      Direct/indirect drives the split on the main page. Changes are saved in this browser.
    </small>
  </div>
</div>

<script>
  const PRODUCTIVITY_STORAGE_KEY = "wiSchedulingProductivity_v7";
  const SCHEDULE_STORAGE_KEY     = "wiSchedulingData_v1";
  const MHE_ASSETS_STORAGE_KEY   = "wiSchedulingMheAssets_v3";
  const INDIRECT_LIMIT_KEY       = "wiSchedulingIndirectLimit_v1";

  let scheduleData = {};
  let currentContext = { date: "", shift: "AM" };
  let viewMode = "Shift";
  let lastRangeSummary = [];
  let allowedIndirectPercent = 5; // default

  // Base task list – each has a category: Direct / Indirect
  let tasksMasterData = [
    { id: "trailer_unload", name: "Trailer unload (rear tip)", area: "Inbound – BAYM", mhe: "PPT",   uom: "Pallets", minutesPerUnit: 2.0, category: "Direct" },
    { id: "container_20",   name: "Container unload (20ft)",   area: "Inbound",       mhe: "PPT",   uom: "Pallets", minutesPerUnit: 2.5, category: "Direct" },
    { id: "container_40",   name: "Container unload (40ft)",   area: "Inbound",       mhe: "PPT",   uom: "Pallets", minutesPerUnit: 3.0, category: "Direct" },
    { id: "putaway_vna",    name: "Putaway – VNA",             area: "High bay",      mhe: "VNA",   uom: "Pallets", minutesPerUnit: 3.0, category: "Direct" },
    { id: "putaway_reach",  name: "Putaway – Reach",           area: "Bulk / floor",  mhe: "Reach", uom: "Pallets", minutesPerUnit: 2.7, category: "Direct" },
    { id: "replenishment",  name: "Replenishment move",        area: "Replen",        mhe: "CB",    uom: "Pallets", minutesPerUnit: 2.2, category: "Direct" },
    { id: "picking_manual", name: "Case picking",              area: "Pick face",     mhe: "Manual",uom: "Units",   minutesPerUnit: 0.1, category: "Direct" },
    { id: "picking_ppt",    name: "Pallet picking (full)",     area: "Pick face",     mhe: "PPT",   uom: "Pallets", minutesPerUnit: 2.4, category: "Direct" },
    { id: "admin_inbound",  name: "Admin – inbound",           area: "Office",        mhe: "Admin", uom: "Units",   minutesPerUnit: 0.6, category: "Indirect" }
  ];

  let mheAssets = [];

  document.addEventListener("DOMContentLoaded", () => {
    initDate();
    initRangeDates();
    loadProductivityFromStorage();
    loadScheduleFromStorage();
    loadMheAssetsFromStorage();
    loadIndirectLimitFromStorage();

    buildTasksTable();
    buildMheConfigTable();
    buildSummaryByMheTable();
    buildTaskConfigTable();

    bindUpload();
    bindDownloadTemplate();
    bindDownloadFullData();
    bindClearVolumes();
    bindContextChange();
    bindViewModeChange();
    bindRangeSummaryControls();
    initSidebar();
    initIndirectLimitControl();

    currentContext = getCurrentContext();
    refreshView();
    buildRangeSummary();
  });

  function initDate() {
    const input = document.getElementById("shift-date");
    const today = new Date();
    const isoToday = today.toISOString().split("T")[0];
    input.value = isoToday;
  }

  function initRangeDates() {
    const from = document.getElementById("range-from");
    const to   = document.getElementById("range-to");
    const today = new Date();
    const isoToday = today.toISOString().split("T")[0];
    from.value = isoToday;
    to.value   = isoToday;
  }

  function getCurrentContext() {
    const dateEl  = document.getElementById("shift-date");
    const shiftEl = document.getElementById("shift-name");
    return {
      date: (dateEl.value || "").trim(),
      shift: (shiftEl.value || "AM").trim()
    };
  }

  function getMheTypes() {
    const set = new Set();

    // Only types from the MHE assets grid
    mheAssets.forEach(a => {
      if (a.type && a.type.trim()) set.add(a.type.trim());
    });

    // Fallback if user has no MHE rows at all:
    if (set.size === 0) {
      ["PPT", "CB", "VNA"].forEach(t => set.add(t));
    }

    return Array.from(set);
  }

  function bindContextChange() {
    document.getElementById("shift-date").addEventListener("change", () => {
      currentContext = getCurrentContext();
      refreshView();
    });
    document.getElementById("shift-name").addEventListener("change", () => {
      currentContext = getCurrentContext();
      refreshView();
    });
  }

  function bindViewModeChange() {
    const sel = document.getElementById("view-mode");
    sel.addEventListener("change", () => {
      viewMode = sel.value || "Shift";
      refreshView();
    });
  }

  function refreshView() {
    const tasksReadonlyNote = document.getElementById("tasks-readonly-note");
    const tasksCaption      = document.getElementById("tasks-caption");
    const summaryCaption    = document.getElementById("summary-caption");

    const isShift = (viewMode === "Shift");
    const isDay   = (viewMode === "Day");
    const isWeek  = (viewMode === "Week");

    setTaskInputsDisabled(!isShift);
    setAvailableInputsDisabled(!isShift);

    if (isShift) {
      tasksReadonlyNote.style.display = "none";
      tasksCaption.textContent   = "For the selected date and shift.";
      summaryCaption.textContent = "For the selected date and shift.";
      loadContextIntoDom(currentContext);
    } else if (isDay) {
      tasksReadonlyNote.style.display = "block";
      tasksCaption.textContent   = "Aggregated across all shifts for the selected date.";
      summaryCaption.textContent = "Aggregated across all shifts for the selected date.";
      loadAggregatedIntoDom("Day");
    } else if (isWeek) {
      tasksReadonlyNote.style.display = "block";
      tasksCaption.textContent   = "Aggregated across all days in the selected week (Mon–Sun).";
      summaryCaption.textContent = "Aggregated across all days in the selected week (Mon–Sun).";
      loadAggregatedIntoDom("Week");
    }

    recalcAll();
  }

  function buildTasksTable() {
    const tbody = document.querySelector("#tasks-table tbody");
    if (!tbody) return;
    tbody.innerHTML = "";

    tasksMasterData.forEach(task => {
      const row = document.createElement("tr");
      row.dataset.mhe = task.mhe || "";
      row.dataset.taskId = task.id;
      row.dataset.category = task.category || "Direct";

      const mp = typeof task.minutesPerUnit === "number" && !isNaN(task.minutesPerUnit)
        ? task.minutesPerUnit : 0;

      const tdTask = document.createElement("td");
      tdTask.textContent = task.name;
      row.appendChild(tdTask);

      const tdArea = document.createElement("td");
      tdArea.textContent = task.area || "";
      row.appendChild(tdArea);

      const tdMhe = document.createElement("td");
      tdMhe.textContent = task.mhe || "";
      row.appendChild(tdMhe);

      const tdUom = document.createElement("td");
      tdUom.textContent = task.uom || "Units";
      row.appendChild(tdUom);

      const tdMinutes = document.createElement("td");
      tdMinutes.classList.add("numeric", "minutes-cell");
      tdMinutes.textContent = mp.toFixed(2);
      row.appendChild(tdMinutes);

      const tdPlanVol = document.createElement("td");
      tdPlanVol.classList.add("numeric");
      const inputPlanVolume = document.createElement("input");
      inputPlanVolume.type = "number";
      inputPlanVolume.min = "0";
      inputPlanVolume.step = "1";
      inputPlanVolume.value = "";
      inputPlanVolume.classList.add("plan-volume");
      inputPlanVolume.addEventListener("input", () => {
        recalcRow(row);
        recalcSummary();
      });
      tdPlanVol.appendChild(inputPlanVolume);
      row.appendChild(tdPlanVol);

      const tdPlanHours = document.createElement("td");
      tdPlanHours.classList.add("numeric", "plan-hours");
      tdPlanHours.textContent = "0.00";
      row.appendChild(tdPlanHours);

      const tdActualVol = document.createElement("td");
      tdActualVol.classList.add("numeric");
      const inputActualVolume = document.createElement("input");
      inputActualVolume.type = "number";
      inputActualVolume.min = "0";
      inputActualVolume.step = "1";
      inputActualVolume.value = "";
      inputActualVolume.classList.add("actual-volume");
      inputActualVolume.addEventListener("input", () => {
        recalcRow(row);
        recalcSummary();
      });
      tdActualVol.appendChild(inputActualVolume);
      row.appendChild(tdActualVol);

      const tdActualHours = document.createElement("td");
      tdActualHours.classList.add("numeric", "actual-hours");
      tdActualHours.textContent = "0.00";
      row.appendChild(tdActualHours);

      const tdProd = document.createElement("td");
      tdProd.classList.add("numeric", "productivity");
      tdProd.textContent = "-";
      row.appendChild(tdProd);

      tbody.appendChild(row);
    });
  }

  function setTaskInputsDisabled(disabled) {
    document.querySelectorAll(".plan-volume, .actual-volume").forEach(input => {
      input.disabled = disabled;
    });
  }

  function setAvailableInputsDisabled(disabled) {
    document.querySelectorAll(".summary-available-hours").forEach(input => {
      input.disabled = disabled;
    });
  }

  function loadContextIntoDom(ctx) {
    const dateKey  = ctx.date;
    const shiftKey = ctx.shift;
    const ctxData  = (scheduleData[dateKey] || {})[shiftKey] || {};

    document.querySelectorAll("#tasks-table tbody tr").forEach(row => {
      const taskId = row.dataset.taskId;
      const entry  = ctxData[taskId] || {};

      const planInput   = row.querySelector(".plan-volume");
      const actualInput = row.querySelector(".actual-volume");

      if (planInput)   planInput.value   = entry.planVolume   != null ? entry.planVolume   : "";
      if (actualInput) actualInput.value = entry.actualVolume != null ? entry.actualVolume : "";
    });

    setAvailableHoursForContext(ctx);
    recalcAll();
  }

  function setAvailableHoursForContext(ctx) {
    const dateKey  = ctx.date;
    const shiftKey = ctx.shift;
    const ctxData  = (scheduleData[dateKey] || {})[shiftKey] || {};
    const availData = ctxData.__availableByMhe || {};

    document.querySelectorAll("#summary-by-mhe tbody tr").forEach(row => {
      const mhe   = row.dataset.mhe;
      const input = row.querySelector(".summary-available-hours");
      if (!input) return;
      if (availData[mhe] != null) input.value = availData[mhe];
      else input.value = "";
    });
  }

  function getWeekDates(dateStr) {
    const d = new Date(dateStr + "T00:00:00");
    const day = d.getDay();
    const diffToMon = (day + 6) % 7;
    d.setDate(d.getDate() - diffToMon);

    const dates = [];
    for (let i = 0; i < 7; i++) {
      const dd = new Date(d.getTime());
      dd.setDate(d.getDate() + i);
      dates.push(dd.toISOString().split("T")[0]);
    }
    return dates;
  }

  function loadAggregatedIntoDom(mode) {
    const dateKey = currentContext.date;
    if (!dateKey) {
      document.querySelectorAll(".plan-volume, .actual-volume").forEach(i => i.value = "");
      document.querySelectorAll(".summary-available-hours").forEach(i => i.value = "");
      recalcAll();
      return;
    }

    const contexts = [];

    if (mode === "Day") {
      const shiftsObj = scheduleData[dateKey] || {};
      Object.keys(shiftsObj).forEach(shiftKey => {
        contexts.push({ date: dateKey, shift: shiftKey });
      });
    } else if (mode === "Week") {
      const weekDates = getWeekDates(dateKey);
      weekDates.forEach(d => {
        const shiftsObj = scheduleData[d] || {};
        Object.keys(shiftsObj).forEach(shiftKey => {
          contexts.push({ date: d, shift: shiftKey });
        });
      });
    }

    const aggrVolumes = {};
    tasksMasterData.forEach(t => {
      aggrVolumes[t.id] = { plan: 0, actual: 0 };
    });

    const aggrAvailableByMhe = {};

    contexts.forEach(c => {
      const ctxStore = (scheduleData[c.date] || {})[c.shift] || {};
      tasksMasterData.forEach(t => {
        const entry = ctxStore[t.id] || {};
        if (entry.planVolume   != null) aggrVolumes[t.id].plan   += entry.planVolume;
        if (entry.actualVolume != null) aggrVolumes[t.id].actual += entry.actualVolume;
      });

      const avail = ctxStore.__availableByMhe || {};
      Object.keys(avail).forEach(mhe => {
        if (!aggrAvailableByMhe[mhe]) aggrAvailableByMhe[mhe] = 0;
        aggrAvailableByMhe[mhe] += avail[mhe];
      });
    });

    document.querySelectorAll("#tasks-table tbody tr").forEach(row => {
      const taskId  = row.dataset.taskId;
      const volumes = aggrVolumes[taskId] || { plan: 0, actual: 0 };

      const planInput   = row.querySelector(".plan-volume");
      const actualInput = row.querySelector(".actual-volume");

      if (planInput)   planInput.value   = volumes.plan   || "";
      if (actualInput) actualInput.value = volumes.actual || "";

      recalcRow(row, false);
    });

    document.querySelectorAll("#summary-by-mhe tbody tr").forEach(row => {
      const mhe   = row.dataset.mhe;
      const input = row.querySelector(".summary-available-hours");
      const val   = aggrAvailableByMhe[mhe] || 0;
      if (input) input.value = val ? val : "";
    });

    recalcSummary();
  }

  function storeRowVolumes(row) {
    const planVolInput   = row.querySelector(".plan-volume");
    const actualVolInput = row.querySelector(".actual-volume");

    const planVolume   = planVolInput   ? parseFloat(planVolInput.value)   : NaN;
    const actualVolume = actualVolInput ? parseFloat(actualVolInput.value) : NaN;

    const taskId = row.dataset.taskId;
    const ctx    = getCurrentContext();
    if (!ctx.date || !ctx.shift || !taskId) return;

    if (!scheduleData[ctx.date]) scheduleData[ctx.date] = {};
    if (!scheduleData[ctx.date][ctx.shift]) scheduleData[ctx.date][ctx.shift] = {};
    const ctxStore = scheduleData[ctx.date][ctx.shift];

    const entry = ctxStore[taskId] || {};
    if (!isNaN(planVolume))   entry.planVolume   = planVolume;
    if (!isNaN(actualVolume)) entry.actualVolume = actualVolume;
    ctxStore[taskId] = entry;

    saveScheduleToStorage();
  }

  function storeAvailableHoursForCurrentContext() {
    const ctx = getCurrentContext();
    if (!ctx.date || !ctx.shift) return;

    if (!scheduleData[ctx.date]) scheduleData[ctx.date] = {};
    if (!scheduleData[ctx.date][ctx.shift]) scheduleData[ctx.date][ctx.shift] = {};
    const ctxStore = scheduleData[ctx.date][ctx.shift];

    const byMhe = {};
    document.querySelectorAll("#summary-by-mhe tbody tr").forEach(row => {
      const mhe   = row.dataset.mhe;
      const input = row.querySelector(".summary-available-hours");
      const val   = input ? parseFloat(input.value) : NaN;
      if (!isNaN(val)) byMhe[mhe] = val;
    });
    ctxStore.__availableByMhe = byMhe;

    saveScheduleToStorage();
  }

  /* ========= CSV UPLOAD / DOWNLOAD ========= */

  function bindUpload() {
    const uploadInput = document.getElementById("csv-upload");
    uploadInput.addEventListener("change", handleCsvUpload);
  }

  function handleCsvUpload(event) {
    const file = event.target.files[0];
    const msgEl = document.getElementById("upload-message");
    msgEl.textContent = "";
    msgEl.className = "message";

    if (!file) return;

    const reader = new FileReader();
    reader.onload = e => {
      try {
        const text    = e.target.result;
        const records = parseCsv(text);
        const result  = applyCsvToTasks(records);
        msgEl.textContent = `Imported ${result.matched} row(s). ${result.unmatched} row(s) did not match any task name.`;
        msgEl.classList.add(result.unmatched > 0 ? "error" : "success");
      } catch (err) {
        msgEl.textContent = "Error reading CSV: " + err.message;
        msgEl.classList.add("error");
      }
    };
    reader.readAsText(file);
  }

  function parseCsv(text) {
    const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
    if (lines.length === 0) return [];

    const header      = lines[0].split(",").map(h => h.trim());
    const lowerHeader = header.map(h => h.toLowerCase());

    const idxTask = lowerHeader.indexOf("task");
    if (idxTask === -1) throw new Error("No 'Task' column found in header.");

    const idxDate   = lowerHeader.indexOf("date");
    const idxShift  = lowerHeader.indexOf("shift");
    const idxPlan   = findColumnIndex(lowerHeader, ["planvolume","plan","planned"]);
    const idxActual = findColumnIndex(lowerHeader, ["actualvolume","actual","actuals"]);

    const records = [];

    for (let i = 1; i < lines.length; i++) {
      const parts = lines[i].split(",");
      if (parts.length === 0) continue;

      const taskNameRaw = (parts[idxTask] || "").trim();
      if (!taskNameRaw) continue;

      const dateStr  = idxDate  >= 0 ? (parts[idxDate]  || "").trim() : "";
      const shiftStr = idxShift >= 0 ? (parts[idxShift] || "").trim() : "";

      const planStr   = idxPlan   >= 0 ? (parts[idxPlan]   || "").trim() : "";
      const actualStr = idxActual >= 0 ? (parts[idxActual] || "").trim() : "";

      const planVolume   = planStr   === "" ? null : parseFloat(planStr);
      const actualVolume = actualStr === "" ? null : parseFloat(actualStr);

      records.push({
        taskName: taskNameRaw,
        date:   dateStr || null,
        shift:  shiftStr || null,
        planVolume:   isNaN(planVolume)   ? null : planVolume,
        actualVolume: isNaN(actualVolume) ? null : actualVolume
      });
    }

    return records;
  }

  function findColumnIndex(headers, candidates) {
    for (let i = 0; i < headers.length; i++) {
      for (const c of candidates) {
        if (headers[i].replace(/\s+/g, "") === c) return i;
      }
    }
    return -1;
  }

  function applyCsvToTasks(records) {
    let matched = 0;
    let unmatched = 0;
    const current = getCurrentContext();

    const nameToTask = {};
    tasksMasterData.forEach(t => {
      nameToTask[t.name.trim().toLowerCase()] = t;
    });

    records.forEach(rec => {
      const key  = rec.taskName.trim().toLowerCase();
      const task = nameToTask[key];
      if (!task) {
        unmatched++;
        return;
      }

      const dateKey  = rec.date  || current.date;
      const shiftKey = rec.shift || current.shift;
      if (!dateKey || !shiftKey) {
        unmatched++;
        return;
      }

      if (!scheduleData[dateKey]) scheduleData[dateKey] = {};
      if (!scheduleData[dateKey][shiftKey]) scheduleData[dateKey][shiftKey] = {};
      const ctxStore = scheduleData[dateKey][shiftKey];

      const entry = ctxStore[task.id] || {};
      if (rec.planVolume   !== null) entry.planVolume   = rec.planVolume;
      if (rec.actualVolume !== null) entry.actualVolume = rec.actualVolume;
      ctxStore[task.id] = entry;

      if (dateKey === current.date && shiftKey === current.shift && viewMode === "Shift") {
        const row = document.querySelector(`#tasks-table tbody tr[data-task-id="${task.id}"]`);
        if (row) {
          const planInput   = row.querySelector(".plan-volume");
          const actualInput = row.querySelector(".actual-volume");
          if (planInput && rec.planVolume !== null)     planInput.value   = rec.planVolume;
          if (actualInput && rec.actualVolume !== null) actualInput.value = rec.actualVolume;
          recalcRow(row, false);
        }
      }
      matched++;
    });

    saveScheduleToStorage();
    refreshView();
    buildRangeSummary();
    return { matched, unmatched };
  }

  function bindClearVolumes() {
    const btn = document.getElementById("btn-clear-volumes");
    btn.addEventListener("click", () => {
      document.querySelectorAll(".plan-volume, .actual-volume").forEach(input => {
        input.value = "";
      });
      document.querySelectorAll(".summary-available-hours").forEach(input => {
        input.value = "";
      });

      scheduleData = {};
      saveScheduleToStorage();
      recalcAll();
      buildRangeSummary();

      const msgEl = document.getElementById("upload-message");
      msgEl.textContent = "All plan and actual volumes cleared for all days/shifts.";
      msgEl.className = "message success";
    });
  }

  function bindDownloadTemplate() {
    const btn = document.getElementById("btn-download-template");
    btn.addEventListener("click", () => {
      const csv  = buildTemplateCsv();
      const blob = new Blob([csv], { type: "text/csv" });
      const url  = URL.createObjectURL(blob);
      const a    = document.createElement("a");
      a.href = url;
      a.download = "scheduling-template.csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      const msgEl = document.getElementById("upload-message");
      msgEl.textContent = "Template downloaded: scheduling-template.csv";
      msgEl.className = "message success";
    });
  }

  function buildTemplateCsv() {
    const ctx = getCurrentContext();
    let lines = [];
    lines.push("Date,Shift,Task,PlanVolume,ActualVolume");
    tasksMasterData.forEach(t => {
      const taskField = escapeCsvField(t.name);
      lines.push(`${ctx.date},${ctx.shift},${taskField},,`);
    });
    return lines.join("\n");
  }

  function bindDownloadFullData() {
    const btn = document.getElementById("btn-download-full-data");
    btn.addEventListener("click", () => {
      const csv  = buildFullDataCsv();
      const blob = new Blob([csv], { type: "text/csv" });
      const url  = URL.createObjectURL(blob);
      const a    = document.createElement("a");
      a.href = url;
      a.download = "scheduling-full-dataset.csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      const msgEl = document.getElementById("upload-message");
      msgEl.textContent = "Full dataset downloaded: scheduling-full-dataset.csv";
      msgEl.className = "message success";
    });
  }

  function buildFullDataCsv() {
    let lines = [];
    lines.push("Date,Shift,Task,Unit,Category,PlanVolume,ActualVolume,MinutesPerUnit,PlanHours,ActualHours");

    const minutesMap = {};
    const uomMap     = {};
    const catMap     = {};
    tasksMasterData.forEach(t => {
      minutesMap[t.id] = typeof t.minutesPerUnit === "number" ? t.minutesPerUnit : 0;
      uomMap[t.id]     = t.uom || "Units";
      catMap[t.id]     = t.category || "Direct";
    });

    const dates = Object.keys(scheduleData).sort();
    dates.forEach(dateKey => {
      const shiftsObj = scheduleData[dateKey] || {};
      Object.keys(shiftsObj).forEach(shiftKey => {
        const ctxStore = shiftsObj[shiftKey] || {};
        tasksMasterData.forEach(t => {
          const entry = ctxStore[t.id];
          if (!entry || (entry.planVolume == null && entry.actualVolume == null)) return;

          const mp  = minutesMap[t.id] || 0;
          const uom = uomMap[t.id] || "Units";
          const cat = catMap[t.id] || "Direct";

          const pv = entry.planVolume;
          const av = entry.actualVolume;
          const planHours   = pv != null ? (pv * mp) / 60 : null;
          const actualHours = av != null ? (av * mp) / 60 : null;

          const row = [
            dateKey,
            shiftKey,
            escapeCsvField(t.name),
            uom,
            cat,
            pv != null ? pv : "",
            av != null ? av : "",
            mp,
            planHours   != null ? planHours.toFixed(2)   : "",
            actualHours != null ? actualHours.toFixed(2) : ""
          ];
          lines.push(row.join(","));
        });
      });
    });

    return lines.join("\n");
  }

  function escapeCsvField(value) {
    if (value == null) return "";
    const s = String(value);
    if (s.includes('"') || s.includes(",") || s.includes("\n")) {
      return '"' + s.replace(/"/g, '""') + '"';
    }
    return s;
  }

  /* ========= RANGE SUMMARY ========= */

  function bindRangeSummaryControls() {
    document.getElementById("btn-refresh-range").addEventListener("click", buildRangeSummary);
    document.getElementById("range-from").addEventListener("change", buildRangeSummary);
    document.getElementById("range-to").addEventListener("change", buildRangeSummary);

    document.getElementById("btn-download-range-csv").addEventListener("click", () => {
      const csv = buildRangeSummaryCsv();
      const blob = new Blob([csv], { type: "text/csv" });
      const url  = URL.createObjectURL(blob);
      const a    = document.createElement("a");
      a.href = url;
      a.download = "scheduling-range-summary.csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    document.getElementById("btn-print-range").addEventListener("click", () => {
      window.print();
    });
  }

  function getDateRange(from, to) {
    const start = new Date(from + "T00:00:00");
    const end   = new Date(to   + "T00:00:00");
    const dates = [];
    let d = new Date(start.getTime());
    while (d <= end) {
      dates.push(d.toISOString().split("T")[0]);
      d.setDate(d.getDate() + 1);
    }
    return dates;
  }

  function computeDailyTotals(dateKey) {
    const dayStore = scheduleData[dateKey];
    if (!dayStore) return null;

    let planHoursTotal = 0;
    let actualHoursTotal = 0;
    let availableHoursTotal = 0;

    const minutesMap = {};
    tasksMasterData.forEach(t => { minutesMap[t.id] = typeof t.minutesPerUnit === "number" ? t.minutesPerUnit : 0; });

    Object.keys(dayStore).forEach(shiftKey => {
      const ctxStore = dayStore[shiftKey] || {};

      tasksMasterData.forEach(t => {
        const entry = ctxStore[t.id] || {};
        const mp = minutesMap[t.id] || 0;

        if (entry.planVolume != null) {
          planHoursTotal += (entry.planVolume * mp) / 60;
        }
        if (entry.actualVolume != null) {
          actualHoursTotal += (entry.actualVolume * mp) / 60;
        }
      });

      const avail = ctxStore.__availableByMhe || {};
      Object.keys(avail).forEach(mhe => {
        const val = avail[mhe];
        if (typeof val === "number") {
          availableHoursTotal += val;
        }
      });
    });

    if (planHoursTotal === 0 && actualHoursTotal === 0 && availableHoursTotal === 0) {
      return null;
    }

    return {
      date: dateKey,
      planHours: planHoursTotal,
      actualHours: actualHoursTotal,
      availableHours: availableHoursTotal,
      planVariance: availableHoursTotal - planHoursTotal,
      actualVariance: availableHoursTotal - actualHoursTotal
    };
  }

  function buildRangeSummary() {
    const fromEl = document.getElementById("range-from");
    const toEl   = document.getElementById("range-to");
    const tbody  = document.querySelector("#range-summary-table tbody");
    tbody.innerHTML = "";
    lastRangeSummary = [];

    const from = fromEl.value;
    const to   = toEl.value;
    if (!from || !to) return;
    if (from > to) return;

    const dates = getDateRange(from, to);

    dates.forEach(dateKey => {
      const totals = computeDailyTotals(dateKey);
      if (!totals) return;

      lastRangeSummary.push(totals);

      const tr = document.createElement("tr");

      const tdDate   = document.createElement("td");
      const tdPlan   = document.createElement("td");
      const tdAvail  = document.createElement("td");
      const tdActual = document.createElement("td");
      const tdPlanVar   = document.createElement("td");
      const tdActualVar = document.createElement("td");

      tdDate.textContent = dateKey;
      tdPlan.textContent   = totals.planHours.toFixed(2);
      tdAvail.textContent  = totals.availableHours.toFixed(2);
      tdActual.textContent = totals.actualHours.toFixed(2);
      tdPlanVar.textContent   = totals.planVariance.toFixed(2);
      tdActualVar.textContent = totals.actualVariance.toFixed(2);

      [tdPlan, tdAvail, tdActual, tdPlanVar, tdActualVar].forEach(td => td.classList.add("numeric"));

      tr.appendChild(tdDate);
      tr.appendChild(tdPlan);
      tr.appendChild(tdAvail);
      tr.appendChild(tdActual);
      tr.appendChild(tdPlanVar);
      tr.appendChild(tdActualVar);

      tbody.appendChild(tr);
    });
  }

  function buildRangeSummaryCsv() {
    let lines = [];
    lines.push("Date,PlannedHours,AvailableHours,ActualHours,PlanVariance,ActualVariance");
    lastRangeSummary.forEach(r => {
      const row = [
        r.date,
        r.planHours.toFixed(2),
        r.availableHours.toFixed(2),
        r.actualHours.toFixed(2),
        r.planVariance.toFixed(2),
        r.actualVariance.toFixed(2)
      ];
      lines.push(row.join(","));
    });
    return lines.join("\n");
  }

  /* ========= CALCULATIONS ========= */

  function recalcAll() {
    document.querySelectorAll("#tasks-table tbody tr").forEach(row => {
      recalcRow(row, viewMode === "Shift");
    });
    recalcSummary();
  }

  function recalcRow(row, persist = (viewMode === "Shift")) {
    const minutesCell = row.querySelector(".minutes-cell");
    const mp = minutesCell ? (parseFloat(minutesCell.textContent) || 0) : 0;

    const planVolInput   = row.querySelector(".plan-volume");
    const actualVolInput = row.querySelector(".actual-volume");

    const planVolume   = planVolInput   ? (parseFloat(planVolInput.value)   || 0) : 0;
    const actualVolume = actualVolInput ? (parseFloat(actualVolInput.value) || 0) : 0;

    const planHours   = mp > 0 ? (planVolume   * mp) / 60 : 0;
    const actualHours = mp > 0 ? (actualVolume * mp) / 60 : 0;

    const planHoursCell   = row.querySelector(".plan-hours");
    const actualHoursCell = row.querySelector(".actual-hours");
    const prodCell        = row.querySelector(".productivity");

    if (planHoursCell)   planHoursCell.textContent   = planHours.toFixed(2);
    if (actualHoursCell) actualHoursCell.textContent = actualHours.toFixed(2);

    // Productivity (units/hr) = Actual volume / Actual hours
    if (prodCell) {
      if (actualHours > 0 && actualVolume > 0) {
        const productivity = actualVolume / actualHours;
        if (isFinite(productivity)) prodCell.textContent = productivity.toFixed(1);
        else prodCell.textContent = "-";
      } else {
        prodCell.textContent = "-";
      }
    }

    // Row-level red/green for tasks: actual hours vs plan hours
    row.classList.remove("table-row-warning", "table-row-ok");
    if (planHours > 0 || actualHours > 0) {
      if (actualHours > planHours + 0.01) {
        row.classList.add("table-row-warning");
      } else if (actualHours > 0 && actualHours <= planHours + 0.01) {
        row.classList.add("table-row-ok");
      }
    }

    if (persist && viewMode === "Shift") {
      storeRowVolumes(row);
    }
  }

  function getCostPerHourForMhe(mheType) {
    let cost = 0;
    mheAssets.forEach(a => {
      if (a.type && a.type.trim() === mheType && a.costPerHour != null && !isNaN(a.costPerHour)) {
        cost = a.costPerHour;
      }
    });
    return cost;
  }

  function recalcSummary() {
    const sums = {}; // per MHE
    let totalPlanDirect   = 0;
    let totalPlanIndirect = 0;
    let totalActualDirect   = 0;
    let totalActualIndirect = 0;

    // First pass – by task row
    document.querySelectorAll("#tasks-table tbody tr").forEach(row => {
      const mhe       = (row.dataset.mhe || "").trim();
      const category  = (row.dataset.category || "Direct");
      const planHoursCell   = row.querySelector(".plan-hours");
      const actualHoursCell = row.querySelector(".actual-hours");

      const planHours   = planHoursCell   ? (parseFloat(planHoursCell.textContent)   || 0) : 0;
      const actualHours = actualHoursCell ? (parseFloat(actualHoursCell.textContent) || 0) : 0;

      if (mhe) {
        if (!sums[mhe]) sums[mhe] = { plan: 0, actual: 0 };
        sums[mhe].plan   += planHours;
        sums[mhe].actual += actualHours;
      }

      if (category === "Indirect") {
        totalPlanIndirect   += planHours;
        totalActualIndirect += actualHours;
      } else {
        totalPlanDirect   += planHours;
        totalActualDirect += actualHours;
      }
    });

    const totalPlan   = totalPlanDirect   + totalPlanIndirect;
    const totalActual = totalActualDirect + totalActualIndirect;

    // Second pass – by MHE summary table
    let totalAvailable   = 0;
    let totalPlannedCost = 0;
    let totalActualCost  = 0;

    document.querySelectorAll("#summary-by-mhe tbody tr").forEach(row => {
      const mhe   = (row.dataset.mhe || "").trim();
      const data  = sums[mhe] || { plan: 0, actual: 0 };

      row.classList.remove("table-row-warning", "table-row-ok");

      const planCell     = row.querySelector(".summary-plan-hours");
      const actualCell   = row.querySelector(".summary-actual-hours");
      const availInput   = row.querySelector(".summary-available-hours");
      const planVarCell  = row.querySelector(".summary-plan-variance");
      const actualVarCell= row.querySelector(".summary-actual-variance");
      const rateCell     = row.querySelector(".summary-cost-rate");
      const planCostCell = row.querySelector(".summary-plan-cost");
      const actCostCell  = row.querySelector(".summary-actual-cost");

      const available = availInput ? (parseFloat(availInput.value) || 0) : 0;
      const costRate  = getCostPerHourForMhe(mhe);

      if (planCell)   planCell.textContent   = data.plan.toFixed(2);
      if (actualCell) actualCell.textContent = data.actual.toFixed(2);
      if (rateCell)   rateCell.textContent   = costRate > 0 ? costRate.toFixed(2) : "-";

      const planVariance   = available - data.plan;
      const actualVariance = available - data.actual;

      formatVarianceCell(planVarCell,   planVariance);
      formatVarianceCell(actualVarCell, actualVariance);

      const planCost   = costRate > 0 ? data.plan   * costRate : 0;
      const actualCost = costRate > 0 ? data.actual * costRate : 0;

      if (planCostCell) planCostCell.textContent = planCost.toFixed(2);
      if (actCostCell)  actCostCell.textContent  = actualCost.toFixed(2);

      totalAvailable   += available;
      totalPlannedCost += planCost;
      totalActualCost  += actualCost;

      // Row-level red/green: if any variance negative => red row, if positive capacity and no negatives => green row
      const hasNegative = (planVariance < -0.01) || (actualVariance < -0.01);
      const hasPositive = (planVariance > 0.01)  || (actualVariance > 0.01);

      if (hasNegative) {
        row.classList.add("table-row-warning");
      } else if (hasPositive) {
        row.classList.add("table-row-ok");
      }
    });

    /* === KPI: Direct / Indirect hours === */
    const kpiDirectPlanEl   = document.getElementById("kpi-direct-plan");
    const kpiDirectActualEl = document.getElementById("kpi-direct-actual");
    const kpiIndirectPlanEl   = document.getElementById("kpi-indirect-plan");
    const kpiIndirectActualEl = document.getElementById("kpi-indirect-actual");
    const kpiIndirectPctEl  = document.getElementById("kpi-indirect-pct");
    const directCard   = document.getElementById("kpi-direct-card");
    const indirectCard = document.getElementById("kpi-indirect-card");

    if (kpiDirectPlanEl)   kpiDirectPlanEl.textContent   = totalPlanDirect.toFixed(2);
    if (kpiDirectActualEl) kpiDirectActualEl.textContent = totalActualDirect.toFixed(2);
    if (kpiIndirectPlanEl)   kpiIndirectPlanEl.textContent   = totalPlanIndirect.toFixed(2);
    if (kpiIndirectActualEl) kpiIndirectActualEl.textContent = totalActualIndirect.toFixed(2);

    const planIndirectPct = totalPlan > 0 ? (totalPlanIndirect / totalPlan) * 100 : 0;
    if (kpiIndirectPctEl)  kpiIndirectPctEl.textContent  = planIndirectPct.toFixed(1);

    if (directCard) {
      directCard.classList.remove("warning", "ok");
      if (totalPlanDirect > 0 && totalActualDirect > 0) {
        if (totalActualDirect > totalPlanDirect + 0.01) {
          directCard.classList.add("warning");
        } else {
          directCard.classList.add("ok");
        }
      }
    }

    if (indirectCard) {
      indirectCard.classList.remove("warning", "ok", "indirect-alert");
      if (totalPlan > 0 && totalPlanIndirect > 0) {
        if (planIndirectPct > allowedIndirectPercent + 0.01) {
          indirectCard.classList.add("warning", "indirect-alert");
        } else {
          indirectCard.classList.add("ok");
        }
      }
    }

    /* === KPI: Labour cost === */
    const kpiCostPlanEl   = document.getElementById("kpi-cost-plan");
    const kpiCostActualEl = document.getElementById("kpi-cost-actual");
    const kpiCostNote     = document.getElementById("kpi-cost-note");
    const kpiCostCard     = document.getElementById("kpi-labour-card");

    if (kpiCostPlanEl)   kpiCostPlanEl.textContent   = totalPlannedCost.toFixed(2);
    if (kpiCostActualEl) kpiCostActualEl.textContent = totalActualCost.toFixed(2);

    if (kpiCostCard) {
      kpiCostCard.classList.remove("warning", "ok");
      if (totalPlannedCost === 0 && totalActualCost === 0) {
        kpiCostNote.textContent = "Enter hourly rates and volumes to see labour cost.";
      } else if (totalActualCost > totalPlannedCost + 0.01) {
        kpiCostCard.classList.add("warning");
        kpiCostNote.textContent = "Actual labour cost above expected.";
      } else if (totalActualCost < totalPlannedCost - 0.01) {
        kpiCostCard.classList.add("ok");
        kpiCostNote.textContent = "Actual labour cost below expected.";
      } else {
        kpiCostNote.textContent = "Actual and expected labour cost are roughly aligned.";
      }
    }

    /* === KPI: Total hours & variance === */
    const kpiTotalPlanEl      = document.getElementById("kpi-total-plan");
    const kpiTotalActualEl    = document.getElementById("kpi-total-actual");
    const kpiTotalAvailEl     = document.getElementById("kpi-total-available");
    const kpiTotalVarianceEl  = document.getElementById("kpi-total-variance");
    const totalCard           = document.getElementById("kpi-total-card");

    if (kpiTotalPlanEl)     kpiTotalPlanEl.textContent     = totalPlan.toFixed(2);
    if (kpiTotalActualEl)   kpiTotalActualEl.textContent   = totalActual.toFixed(2);
    if (kpiTotalAvailEl)    kpiTotalAvailEl.textContent    = totalAvailable.toFixed(2);
    const overallVariance = totalAvailable - totalPlan;
    if (kpiTotalVarianceEl) kpiTotalVarianceEl.textContent = overallVariance.toFixed(2);

    if (totalCard) {
      totalCard.classList.remove("warning", "ok");
      if (totalPlan === 0 && totalAvailable === 0) {
        // leave neutral
      } else if (overallVariance < -0.01) {
        totalCard.classList.add("warning");
      } else if (overallVariance > 0.01) {
        totalCard.classList.add("ok");
      }
    }
  }

  function formatVarianceCell(cell, value) {
    if (!cell) return;
    cell.textContent = value.toFixed(2);
    cell.classList.remove("pos", "neg", "neutral", "variance");
    cell.classList.add("variance");
    if (value > 0.01) cell.classList.add("pos");
    else if (value < -0.01) cell.classList.add("neg");
    else cell.classList.add("neutral");
  }

  /* ========= STORAGE ========= */

  function saveProductivityToStorage() {
    try {
      const simple = tasksMasterData.map(t => ({
        id: t.id,
        minutesPerUnit: t.minutesPerUnit,
        uom: t.uom,
        name: t.name,
        area: t.area,
        mhe: t.mhe,
        category: t.category || "Direct"
      }));
      localStorage.setItem(PRODUCTIVITY_STORAGE_KEY, JSON.stringify(simple));
    } catch (e) {}
  }

  function loadProductivityFromStorage() {
    try {
      const raw = localStorage.getItem(PRODUCTIVITY_STORAGE_KEY);
      if (!raw) return;
      const saved = JSON.parse(raw);
      saved.forEach(s => {
        const t = tasksMasterData.find(x => x.id === s.id);
        if (t) {
          if (typeof s.minutesPerUnit === "number") t.minutesPerUnit = s.minutesPerUnit;
          if (s.uom)      t.uom      = s.uom;
          if (s.name)     t.name     = s.name;
          if (s.area)     t.area     = s.area;
          if (s.mhe)      t.mhe      = s.mhe;
          if (s.category) t.category = s.category;
        }
      });
    } catch (e) {}
  }

  function saveScheduleToStorage() {
    try {
      localStorage.setItem(SCHEDULE_STORAGE_KEY, JSON.stringify(scheduleData));
    } catch (e) {}
  }

  function loadScheduleFromStorage() {
    try {
      const raw = localStorage.getItem(SCHEDULE_STORAGE_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed === "object") {
        scheduleData = parsed;
      }
    } catch (e) {}
  }

  function saveMheAssetsToStorage() {
    try {
      localStorage.setItem(MHE_ASSETS_STORAGE_KEY, JSON.stringify(mheAssets));
    } catch (e) {}
  }

  function loadMheAssetsFromStorage() {
    try {
      const raw = localStorage.getItem(MHE_ASSETS_STORAGE_KEY);
      if (!raw) {
        mheAssets = [
          { id: "m1", label: "PPT fleet",   type: "PPT",   count: 4, costPerHour: 18 },
          { id: "m2", label: "CB fleet",    type: "CB",    count: 3, costPerHour: 19 },
          { id: "m3", label: "VNA trucks",  type: "VNA",   count: 2, costPerHour: 21 }
        ];
        return;
      }
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        mheAssets = parsed;
      }
    } catch (e) {}
  }

  function loadIndirectLimitFromStorage() {
    try {
      const raw = localStorage.getItem(INDIRECT_LIMIT_KEY);
      if (!raw) return;
      const v = parseFloat(raw);
      if (!isNaN(v) && v >= 0) {
        allowedIndirectPercent = v;
      }
    } catch (e) {}
  }

  function saveIndirectLimitToStorage() {
    try {
      localStorage.setItem(INDIRECT_LIMIT_KEY, String(allowedIndirectPercent));
    } catch (e) {}
  }

  function initIndirectLimitControl() {
    const input = document.getElementById("indirect-limit");
    if (!input) return;
    input.value = allowedIndirectPercent.toString();
    input.addEventListener("change", () => {
      const v = parseFloat(input.value);
      if (!isNaN(v) && v >= 0) {
        allowedIndirectPercent = v;
      } else {
        allowedIndirectPercent = 0;
        input.value = "0";
      }
      saveIndirectLimitToStorage();
      recalcSummary();
    });
  }

  /* ========= SUMMARY BY MHE TABLE ========= */

  function buildSummaryByMheTable() {
    const tbody = document.querySelector("#summary-by-mhe tbody");
    if (!tbody) return;
    tbody.innerHTML = "";

    const types = getMheTypes();
    types.forEach(type => {
      const tr = document.createElement("tr");
      tr.dataset.mhe = type;

      const tdLabel = document.createElement("td");
      const span = document.createElement("span");
      span.className = "pill";
      span.textContent = type;
      tdLabel.appendChild(span);

      const tdRate = document.createElement("td");
      tdRate.className = "numeric summary-cost-rate";
      tdRate.textContent = "-";

      const tdPlan = document.createElement("td");
      tdPlan.className = "numeric summary-plan-hours";
      tdPlan.textContent = "0.00";

      const tdPlanCost = document.createElement("td");
      tdPlanCost.className = "numeric summary-plan-cost";
      tdPlanCost.textContent = "0.00";

      const tdAvail = document.createElement("td");
      tdAvail.className = "numeric";
      const inpAvail = document.createElement("input");
      inpAvail.type = "number";
      inpAvail.className = "summary-available-hours";
      inpAvail.step = "0.25";
      inpAvail.min  = "0";
      inpAvail.placeholder = "0.00";
      inpAvail.addEventListener("input", () => {
        if (viewMode === "Shift") {
          storeAvailableHoursForCurrentContext();
          recalcSummary();
        }
      });
      tdAvail.appendChild(inpAvail);

      const tdPlanVar = document.createElement("td");
      tdPlanVar.className = "numeric variance summary-plan-variance neutral";
      tdPlanVar.textContent = "0.00";

      const tdActual = document.createElement("td");
      tdActual.className = "numeric summary-actual-hours";
      tdActual.textContent = "0.00";

      const tdActualCost = document.createElement("td");
      tdActualCost.className = "numeric summary-actual-cost";
      tdActualCost.textContent = "0.00";

      const tdActualVar = document.createElement("td");
      tdActualVar.className = "numeric variance summary-actual-variance neutral";
      tdActualVar.textContent = "0.00";

      tr.appendChild(tdLabel);
      tr.appendChild(tdRate);
      tr.appendChild(tdPlan);
      tr.appendChild(tdPlanCost);
      tr.appendChild(tdAvail);
      tr.appendChild(tdPlanVar);
      tr.appendChild(tdActual);
      tr.appendChild(tdActualCost);
      tr.appendChild(tdActualVar);

      tbody.appendChild(tr);
    });

    updateMheTotalCount();
    setAvailableHoursForContext(currentContext);
    recalcSummary();
  }

  /* ========= SIDEBAR (MHE + TASK CONFIG) ========= */

  function initSidebar() {
    const sidebar = document.getElementById("config-sidebar");
    const toggleBtn = document.getElementById("btn-toggle-sidebar");
    const closeBtn  = document.getElementById("sidebar-close");

    toggleBtn.addEventListener("click", () => {
      sidebar.classList.add("open");
      buildMheConfigTable();
      buildSummaryByMheTable();
      buildTaskConfigTable();
    });
    closeBtn.addEventListener("click", () => {
      sidebar.classList.remove("open");
    });

    document.getElementById("btn-add-mhe-row").addEventListener("click", () => {
      const id = "mhe_" + Date.now().toString(36);
      mheAssets.push({ id, label: "New MHE", type: "", count: 1, costPerHour: 0 });
      saveMheAssetsToStorage();
      buildMheConfigTable();
      buildSummaryByMheTable();
      buildTaskConfigTable();
    });

    document.getElementById("btn-add-task-row").addEventListener("click", () => {
      const id = "task_" + Date.now().toString(36);
      const types = getMheTypes();
      tasksMasterData.push({
        id,
        name: "New task",
        area: "",
        mhe: types[0] || "",
        uom: "Pallets",
        minutesPerUnit: 2.0,
        category: "Direct"
      });
      saveProductivityToStorage();
      buildTasksTable();
      refreshView();
      buildRangeSummary();
      buildTaskConfigTable();
    });
  }

  function buildMheConfigTable() {
    const tbody = document.querySelector("#mhe-config-table tbody");
    if (!tbody) return;
    tbody.innerHTML = "";

    mheAssets.forEach(asset => {
      const tr = document.createElement("tr");

      const tdLabel = document.createElement("td");
      const inpLabel = document.createElement("input");
      inpLabel.type = "text";
      inpLabel.value = asset.label || "";
      inpLabel.addEventListener("input", () => {
        asset.label = inpLabel.value;
        saveMheAssetsToStorage();
      });
      tdLabel.appendChild(inpLabel);

      const tdType = document.createElement("td");
      const inpType = document.createElement("input");
      inpType.type = "text";
      inpType.value = asset.type || "";
      inpType.addEventListener("input", () => {
        asset.type = inpType.value;
        saveMheAssetsToStorage();
        buildSummaryByMheTable();
        buildTaskConfigTable();
      });
      tdType.appendChild(inpType);

      const tdCount = document.createElement("td");
      const inpCount = document.createElement("input");
      inpCount.type = "number";
      inpCount.step = "1";
      inpCount.min  = "0";
      inpCount.value = asset.count != null ? asset.count : "";
      inpCount.addEventListener("input", () => {
        const val = parseInt(inpCount.value, 10);
        asset.count = isNaN(val) ? 0 : val;
        saveMheAssetsToStorage();
        updateMheTotalCount();
      });
      tdCount.appendChild(inpCount);

      const tdCost = document.createElement("td");
      const inpCost = document.createElement("input");
      inpCost.type = "number";
      inpCost.step = "0.01";
      inpCost.min  = "0";
      inpCost.value = asset.costPerHour != null ? asset.costPerHour : "";
      inpCost.addEventListener("input", () => {
        const v = parseFloat(inpCost.value);
        asset.costPerHour = !isNaN(v) && v >= 0 ? v : 0;
        saveMheAssetsToStorage();
        recalcSummary();
      });
      tdCost.appendChild(inpCost);

      const tdDel = document.createElement("td");
      const btnDel = document.createElement("button");
      btnDel.type = "button";
      btnDel.className = "btn-icon";
      btnDel.innerHTML = "&times;";
      btnDel.addEventListener("click", () => {
        mheAssets = mheAssets.filter(a => a.id !== asset.id);
        saveMheAssetsToStorage();
        buildMheConfigTable();
        buildSummaryByMheTable();
        buildTaskConfigTable();
      });
      tdDel.appendChild(btnDel);

      tr.appendChild(tdLabel);
      tr.appendChild(tdType);
      tr.appendChild(tdCount);
      tr.appendChild(tdCost);
      tr.appendChild(tdDel);

      tbody.appendChild(tr);
    });

    updateMheTotalCount();
  }

  function updateMheTotalCount() {
    let total = 0;
    mheAssets.forEach(a => {
      const c = a.count != null ? parseInt(a.count, 10) : 0;
      if (!isNaN(c)) total += c;
    });
    const span = document.getElementById("mhe-total-count");
    if (span) span.textContent = total;
  }

  function buildTaskConfigTable() {
    const tbody = document.querySelector("#task-config-table tbody");
    if (!tbody) return;
    tbody.innerHTML = "";

    const types = getMheTypes();

    tasksMasterData.forEach(task => {
      const tr = document.createElement("tr");

      const tdName = document.createElement("td");
      const inpName = document.createElement("input");
      inpName.type = "text";
      inpName.value = task.name || "";
      inpName.addEventListener("input", () => {
        task.name = inpName.value;
        saveProductivityToStorage();
        buildTasksTable();
        refreshView();
        buildRangeSummary();
      });
      tdName.appendChild(inpName);

      const tdArea = document.createElement("td");
      const inpArea = document.createElement("input");
      inpArea.type = "text";
      inpArea.value = task.area || "";
      inpArea.addEventListener("input", () => {
        task.area = inpArea.value;
        saveProductivityToStorage();
        buildTasksTable();
        refreshView();
      });
      tdArea.appendChild(inpArea);

      const tdCat = document.createElement("td");
      const selCat = document.createElement("select");
      ["Direct","Indirect"].forEach(cat => {
        const opt = document.createElement("option");
        opt.value = cat;
        opt.textContent = cat;
        if ((task.category || "Direct") === cat) opt.selected = true;
        selCat.appendChild(opt);
      });
      selCat.addEventListener("change", () => {
        task.category = selCat.value;
        saveProductivityToStorage();
        buildTasksTable();
        refreshView();
        buildRangeSummary();
      });
      tdCat.appendChild(selCat);

      const tdMhe = document.createElement("td");
      const selMhe = document.createElement("select");

      // Options only from MHE setup
      types.forEach(mt => {
        const opt = document.createElement("option");
        opt.value = mt;
        opt.textContent = mt;
        selMhe.appendChild(opt);
      });

      if (task.mhe && types.includes(task.mhe)) {
        selMhe.value = task.mhe;
      } else if (types.length > 0 && !task.mhe) {
        selMhe.value = types[0];
        task.mhe = types[0];
      }

      selMhe.addEventListener("change", () => {
        task.mhe = selMhe.value;
        saveProductivityToStorage();
        buildTasksTable();
        refreshView();
        buildRangeSummary();
      });
      tdMhe.appendChild(selMhe);

      const tdUom = document.createElement("td");
      const selUom = document.createElement("select");
      ["Pallets", "Units"].forEach(u => {
        const opt = document.createElement("option");
        opt.value = u;
        opt.textContent = u;
        if (task.uom === u) opt.selected = true;
        selUom.appendChild(opt);
      });
      selUom.addEventListener("change", () => {
        task.uom = selUom.value;
        saveProductivityToStorage();
        buildTasksTable();
        refreshView();
      });
      tdUom.appendChild(selUom);

      const tdMin = document.createElement("td");
      const inpMin = document.createElement("input");
      inpMin.type = "number";
      inpMin.step = "0.1";
      inpMin.min  = "0";
      const mp = typeof task.minutesPerUnit === "number" && !isNaN(task.minutesPerUnit)
        ? task.minutesPerUnit : 0;
      inpMin.value = mp.toFixed(2);
      inpMin.addEventListener("input", () => {
        const v = parseFloat(inpMin.value);
        if (!isNaN(v) && v >= 0) {
          task.minutesPerUnit = v;
          saveProductivityToStorage();
          buildTasksTable();
          refreshView();
          buildRangeSummary();
        }
      });
      tdMin.appendChild(inpMin);

      const tdDel = document.createElement("td");
      const btnDel = document.createElement("button");
      btnDel.type = "button";
      btnDel.className = "btn-icon";
      btnDel.innerHTML = "&times;";
      btnDel.addEventListener("click", () => {
        removeTask(task.id);
      });
      tdDel.appendChild(btnDel);

      tr.appendChild(tdName);
      tr.appendChild(tdArea);
      tr.appendChild(tdCat);
      tr.appendChild(tdMhe);
      tr.appendChild(tdUom);
      tr.appendChild(tdMin);
      tr.appendChild(tdDel);

      tbody.appendChild(tr);
    });
  }

  function removeTask(taskId) {
    tasksMasterData = tasksMasterData.filter(t => t.id !== taskId);

    Object.keys(scheduleData).forEach(dateKey => {
      const shiftsObj = scheduleData[dateKey] || {};
      Object.keys(shiftsObj).forEach(shiftKey => {
        const ctxStore = shiftsObj[shiftKey];
        if (ctxStore && ctxStore[taskId]) delete ctxStore[taskId];
      });
    });

    saveProductivityToStorage();
    saveScheduleToStorage();

    buildTasksTable();
    refreshView();
    buildRangeSummary();
    buildTaskConfigTable();
  }
</script>
</body>
</html>
